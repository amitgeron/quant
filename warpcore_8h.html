<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>quant: deps/warpcore/lib/include/warpcore/warpcore.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">quant
   &#160;<span id="projectnumber">0.0.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_82ce5dd3950c6393668b7cc23fc52b28.html">deps</a></li><li class="navelem"><a class="el" href="dir_63a5f3da5bb346670840ad293d558300.html">warpcore</a></li><li class="navelem"><a class="el" href="dir_f4c0bb2795bdb545195b8a1e3a07cf5b.html">lib</a></li><li class="navelem"><a class="el" href="dir_1dd303864f89ebf3144618036f2bd61e.html">include</a></li><li class="navelem"><a class="el" href="dir_9dd80b6288c5736ac03cb2ca447adb37.html">warpcore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">warpcore.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;sys/time.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="deps_2warpcore_2lib_2include_2warpcore_2config_8h_source.html">warpcore/config.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="plat_8h_source.html">warpcore/plat.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="queue_8h_source.html">warpcore/queue.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="warpcore_2lib_2include_2warpcore_2util_8h_source.html">warpcore/util.h</a>&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for warpcore.h:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h__incl.png" border="0" usemap="#deps_2warpcore_2lib_2include_2warpcore_2warpcore_8h" alt=""/></div>
<map name="deps_2warpcore_2lib_2include_2warpcore_2warpcore_8h" id="deps_2warpcore_2lib_2include_2warpcore_2warpcore_8h">
<area shape="rect" id="node5" href="deps_2warpcore_2lib_2include_2warpcore_2config_8h.html" title="warpcore/config.h" alt="" coords="621,96,747,123"/><area shape="rect" id="node6" href="plat_8h.html" title="warpcore/plat.h" alt="" coords="75,96,185,123"/><area shape="rect" id="node9" href="queue_8h.html" title="warpcore/queue.h" alt="" coords="771,96,896,123"/><area shape="rect" id="node10" href="warpcore_2lib_2include_2warpcore_2util_8h.html" title="warpcore/util.h" alt="" coords="261,96,368,123"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h__dep__incl.png" border="0" usemap="#deps_2warpcore_2lib_2include_2warpcore_2warpcore_8hdep" alt=""/></div>
<map name="deps_2warpcore_2lib_2include_2warpcore_2warpcore_8hdep" id="deps_2warpcore_2lib_2include_2warpcore_2warpcore_8hdep">
<area shape="rect" id="node2" href="inetd_8c.html" title="deps/warpcore/bin/inetd.c" alt="" coords="5,104,176,131"/><area shape="rect" id="node3" href="ping_8c.html" title="deps/warpcore/bin/ping.c" alt="" coords="201,104,367,131"/><area shape="rect" id="node4" href="arp_8c.html" title="deps/warpcore/lib/src\l/arp.c" alt="" coords="467,278,613,319"/><area shape="rect" id="node5" href="backend_8h.html" title="deps/warpcore/lib/src\l/backend.h" alt="" coords="1412,97,1559,138"/><area shape="rect" id="node6" href="backend__netmap_8c.html" title="deps/warpcore/lib/src\l/backend_netmap.c" alt="" coords="747,187,893,229"/><area shape="rect" id="node7" href="backend__sock_8c.html" title="deps/warpcore/lib/src\l/backend_sock.c" alt="" coords="1751,278,1897,319"/><area shape="rect" id="node8" href="eth_8c.html" title="deps/warpcore/lib/src\l/eth.c" alt="" coords="772,278,919,319"/><area shape="rect" id="node9" href="icmp_8c.html" title="deps/warpcore/lib/src\l/icmp.c" alt="" coords="1409,278,1556,319"/><area shape="rect" id="node10" href="ip_8c.html" title="deps/warpcore/lib/src/ip.c" alt="" coords="977,285,1148,312"/><area shape="rect" id="node11" href="udp_8c.html" title="deps/warpcore/lib/src\l/udp.c" alt="" coords="1239,278,1385,319"/><area shape="rect" id="node12" href="warpcore_8c.html" title="deps/warpcore/lib/src\l/warpcore.c" alt="" coords="1624,187,1771,229"/><area shape="rect" id="node13" href="fuzz_8c.html" title="deps/warpcore/test\l/fuzz.c" alt="" coords="917,187,1051,229"/><area shape="rect" id="node14" href="test__iov_8c.html" title="deps/warpcore/test\l/test_iov.c" alt="" coords="1795,187,1928,229"/><area shape="rect" id="node15" href="eth_8h.html" title="deps/warpcore/lib/src\l/eth.h" alt="" coords="747,97,893,138"/><area shape="rect" id="node17" href="in__cksum_8c.html" title="deps/warpcore/lib/src\l/in_cksum.c" alt="" coords="1580,278,1727,319"/><area shape="rect" id="node18" href="plat_8c.html" title="deps/warpcore/lib/src\l/plat.c" alt="" coords="2155,97,2301,138"/><area shape="rect" id="node19" href="deps_2warpcore_2lib_2src_2util_8c.html" title="deps/warpcore/lib/src\l/util.c" alt="" coords="2325,97,2472,138"/><area shape="rect" id="node20" href="common_8c.html" title="deps/warpcore/test\l/common.c" alt="" coords="2496,97,2629,138"/><area shape="rect" id="node21" href="test__hexdump_8c.html" title="deps/warpcore/test\l/test_hexdump.c" alt="" coords="2653,97,2787,138"/><area shape="rect" id="node22" href="test__many_8c.html" title="deps/warpcore/test\l/test_many.c" alt="" coords="2811,97,2944,138"/><area shape="rect" id="node23" href="test__queue_8c.html" title="deps/warpcore/test\l/test_queue.c" alt="" coords="2968,97,3101,138"/><area shape="rect" id="node24" href="test__sock_8c.html" title="deps/warpcore/test\l/test_sock.c" alt="" coords="3125,97,3259,138"/><area shape="rect" id="node25" href="conn_8c.html" title="src/conn.c" alt="" coords="4008,443,4089,469"/><area shape="rect" id="node26" href="conn_8h.html" title="src/conn.h" alt="" coords="4120,285,4201,312"/><area shape="rect" id="node28" href="frame_8c.html" title="src/frame.c" alt="" coords="3708,443,3796,469"/><area shape="rect" id="node29" href="pkt_8c.html" title="src/pkt.c" alt="" coords="3361,443,3433,469"/><area shape="rect" id="node30" href="quic_8c.html" title="src/quic.c" alt="" coords="4641,443,4719,469"/><area shape="rect" id="node31" href="recovery_8c.html" title="src/recovery.c" alt="" coords="4203,443,4308,469"/><area shape="rect" id="node32" href="stream_8c.html" title="src/stream.c" alt="" coords="4743,443,4837,469"/><area shape="rect" id="node33" href="tls_8c.html" title="src/tls.c" alt="" coords="3852,443,3921,469"/><area shape="rect" id="node34" href="stream_8h.html" title="src/stream.h" alt="" coords="4294,368,4388,395"/><area shape="rect" id="node35" href="pn_8c.html" title="src/pn.c" alt="" coords="4468,443,4537,469"/><area shape="rect" id="node36" href="quic_8h.html" title="src/quic.h" alt="" coords="3841,104,3919,131"/><area shape="rect" id="node38" href="recovery_8h.html" title="src/recovery.h" alt="" coords="3638,195,3743,221"/><area shape="rect" id="node39" href="diet_8c.html" title="src/diet.c" alt="" coords="5022,104,5097,131"/><area shape="rect" id="node40" href="marshall_8c.html" title="src/marshall.c" alt="" coords="5123,104,5227,131"/><area shape="rect" id="node41" href="src_2util_8c.html" title="src/util.c" alt="" coords="5251,104,5323,131"/><area shape="rect" id="node16" href="ip_8h.html" title="deps/warpcore/lib/src/ip.h" alt="" coords="1227,195,1397,221"/><area shape="rect" id="node27" href="pkt_8h.html" title="src/pkt.h" alt="" coords="4043,368,4116,395"/><area shape="rect" id="node37" href="pn_8h.html" title="src/pn.h" alt="" coords="4048,195,4117,221"/></map>
</div>
</div>
<p><a href="warpcore_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structw__iov__sq.html">w_iov_sq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tail queue of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> I/O vectors.  <a href="structw__iov__sq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structw__engine.html">w_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A warpcore backend engine.  <a href="structw__engine.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structw__sockopt.html">w_sockopt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket options.  <a href="structw__sockopt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structw__tuple.html">w_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structw__sock.html">w_sock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A warpcore socket.  <a href="structw__sock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structw__iov.html">w_iov</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The I/O vector structure that warpcore uses at the center of its API.  <a href="structw__iov.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adb7cefb61123a68cf87f6e33270af1dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#adb7cefb61123a68cf87f6e33270af1dc">w_iov_sq_initializer</a>(q)</td></tr>
<tr class="memdesc:adb7cefb61123a68cf87f6e33270af1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for struct <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a>.  <a href="#adb7cefb61123a68cf87f6e33270af1dc">More...</a><br/></td></tr>
<tr class="separator:adb7cefb61123a68cf87f6e33270af1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8c618c1c3811f7c7d8350c1c073567"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a6c8c618c1c3811f7c7d8350c1c073567">w_sock_slist_initializer</a>(l)&#160;&#160;&#160;<a class="el" href="queue_8h.html#a3473fc2c9a55a6b7b3a192ddc7589228">sl_head_initializer</a>(l)</td></tr>
<tr class="memdesc:a6c8c618c1c3811f7c7d8350c1c073567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for struct w_sock_slist.  <a href="#a6c8c618c1c3811f7c7d8350c1c073567">More...</a><br/></td></tr>
<tr class="separator:a6c8c618c1c3811f7c7d8350c1c073567"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aef8c8261fc14f3b65fdcc5a297f30cc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#aef8c8261fc14f3b65fdcc5a297f30cc3">sl_head</a> (w_sock_slist, <a class="el" href="structw__sock.html">w_sock</a>)</td></tr>
<tr class="memdesc:aef8c8261fc14f3b65fdcc5a297f30cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chain of <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket.  <a href="#aef8c8261fc14f3b65fdcc5a297f30cc3">More...</a><br/></td></tr>
<tr class="separator:aef8c8261fc14f3b65fdcc5a297f30cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82d2bc9bb47d5a72795267fe6ef3af3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#af82d2bc9bb47d5a72795267fe6ef3af3">w_iov_idx</a> (const struct <a class="el" href="structw__iov.html">w_iov</a> *const v)</td></tr>
<tr class="memdesc:af82d2bc9bb47d5a72795267fe6ef3af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> <code>v</code>.  <a href="#af82d2bc9bb47d5a72795267fe6ef3af3">More...</a><br/></td></tr>
<tr class="separator:af82d2bc9bb47d5a72795267fe6ef3af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af715f1dc66886b692a243b014997f171"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structw__iov.html">w_iov</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#af715f1dc66886b692a243b014997f171">w_iov</a> (const struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, const uint32_t i)</td></tr>
<tr class="memdesc:af715f1dc66886b692a243b014997f171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> with index <code>i</code>.  <a href="#af715f1dc66886b692a243b014997f171">More...</a><br/></td></tr>
<tr class="separator:af715f1dc66886b692a243b014997f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8850127dfaca15991ddd916380ce4d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__engine.html">w_engine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a3d8850127dfaca15991ddd916380ce4d">w_init</a> (const char *const ifname, const uint32_t rip, const uint64_t nbufs)</td></tr>
<tr class="memdesc:a3d8850127dfaca15991ddd916380ce4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a warpcore engine on the given interface.  <a href="#a3d8850127dfaca15991ddd916380ce4d">More...</a><br/></td></tr>
<tr class="separator:a3d8850127dfaca15991ddd916380ce4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726b06c06493678f7f48c889bbcd30a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a726b06c06493678f7f48c889bbcd30a5">w_cleanup</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>)</td></tr>
<tr class="memdesc:a726b06c06493678f7f48c889bbcd30a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut a warpcore engine down cleanly.  <a href="#a726b06c06493678f7f48c889bbcd30a5">More...</a><br/></td></tr>
<tr class="separator:a726b06c06493678f7f48c889bbcd30a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5c782e319686927159612d3f455b7b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__sock.html">w_sock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a8f5c782e319686927159612d3f455b7b">w_bind</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, const uint16_t port, const struct <a class="el" href="structw__sockopt.html">w_sockopt</a> *const opt)</td></tr>
<tr class="memdesc:a8f5c782e319686927159612d3f455b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to the given local UDP port number.  <a href="#a8f5c782e319686927159612d3f455b7b">More...</a><br/></td></tr>
<tr class="separator:a8f5c782e319686927159612d3f455b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade6adf37002553de6cca667cacd5138"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#aade6adf37002553de6cca667cacd5138">w_connect</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s, const uint32_t ip, const uint16_t port)</td></tr>
<tr class="memdesc:aade6adf37002553de6cca667cacd5138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a bound socket to a remote IP address and port.  <a href="#aade6adf37002553de6cca667cacd5138">More...</a><br/></td></tr>
<tr class="separator:aade6adf37002553de6cca667cacd5138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c31751f7bb602b01bf00077ebd362d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a26c31751f7bb602b01bf00077ebd362d">w_close</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a26c31751f7bb602b01bf00077ebd362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a warpcore socket.  <a href="#a26c31751f7bb602b01bf00077ebd362d">More...</a><br/></td></tr>
<tr class="separator:a26c31751f7bb602b01bf00077ebd362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7828b02675cf9e9c1465f3162033e22c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a7828b02675cf9e9c1465f3162033e22c">w_alloc_len</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const q, const uint64_t qlen, const uint16_t <a class="el" href="t_2picotls_8c.html#a7360b55975153b822efc5217b7734e6a">len</a>, const uint16_t off)</td></tr>
<tr class="memdesc:a7828b02675cf9e9c1465f3162033e22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue for <code>plen</code> payload bytes, for eventual use with <a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51" title="Loops over the w_iov structures in the w_iov_sq o, sending them all over w_sock s. ">w_tx()</a>.  <a href="#a7828b02675cf9e9c1465f3162033e22c">More...</a><br/></td></tr>
<tr class="separator:a7828b02675cf9e9c1465f3162033e22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eaba9c2482e4f78925648d3e12524d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a8eaba9c2482e4f78925648d3e12524d3">w_alloc_cnt</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const q, const uint64_t <a class="el" href="t_2picotls_8c.html#a76d971a3c552bc58ba9f0d5fceae9806">count</a>, const uint16_t <a class="el" href="t_2picotls_8c.html#a7360b55975153b822efc5217b7734e6a">len</a>, const uint16_t off)</td></tr>
<tr class="memdesc:a8eaba9c2482e4f78925648d3e12524d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue of <code>count</code> packets, for eventual use with <a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51" title="Loops over the w_iov structures in the w_iov_sq o, sending them all over w_sock s. ">w_tx()</a>.  <a href="#a8eaba9c2482e4f78925648d3e12524d3">More...</a><br/></td></tr>
<tr class="separator:a8eaba9c2482e4f78925648d3e12524d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e20ed409edbfe18aa79ae5da640ff"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__iov.html">w_iov</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#aa17e20ed409edbfe18aa79ae5da640ff">w_alloc_iov</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, const uint16_t <a class="el" href="t_2picotls_8c.html#a7360b55975153b822efc5217b7734e6a">len</a>, const uint16_t off)</td></tr>
<tr class="memdesc:aa17e20ed409edbfe18aa79ae5da640ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a spare <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> from the pool of the given warpcore engine.  <a href="#aa17e20ed409edbfe18aa79ae5da640ff">More...</a><br/></td></tr>
<tr class="separator:aa17e20ed409edbfe18aa79ae5da640ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f053bd8ffef52d164823134d732f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51">w_tx</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s, struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const o)</td></tr>
<tr class="memdesc:ac4f053bd8ffef52d164823134d732f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops over the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a> <code>o</code>, sending them all over <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>.  <a href="#ac4f053bd8ffef52d164823134d732f51">More...</a><br/></td></tr>
<tr class="separator:ac4f053bd8ffef52d164823134d732f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec933a0dba371ff10bd35397aed87e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#acec933a0dba371ff10bd35397aed87e9">w_iov_sq_len</a> (const struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const q)</td></tr>
<tr class="memdesc:acec933a0dba371ff10bd35397aed87e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total payload length of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>c</code>.  <a href="#acec933a0dba371ff10bd35397aed87e9">More...</a><br/></td></tr>
<tr class="separator:acec933a0dba371ff10bd35397aed87e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf46056f39cb452d908ddac8cf6e57c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#aaf46056f39cb452d908ddac8cf6e57c5">w_fd</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:aaf46056f39cb452d908ddac8cf6e57c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file descriptor associated with a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>.  <a href="#aaf46056f39cb452d908ddac8cf6e57c5">More...</a><br/></td></tr>
<tr class="separator:aaf46056f39cb452d908ddac8cf6e57c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21a4e848c9199be729d01d20b8eea3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d">w_rx</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s, struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const i)</td></tr>
<tr class="memdesc:af21a4e848c9199be729d01d20b8eea3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return any new data that has been received on a socket by appending it to the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>i</code>.  <a href="#af21a4e848c9199be729d01d20b8eea3d">More...</a><br/></td></tr>
<tr class="separator:af21a4e848c9199be729d01d20b8eea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fba5669717435248ca7b7945a9b9d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a3fba5669717435248ca7b7945a9b9d75">w_nic_tx</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>)</td></tr>
<tr class="memdesc:a3fba5669717435248ca7b7945a9b9d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push data placed in the TX rings via <a class="el" href="udp_8c.html#a5ff6c06e976086b17457bc7766bb8e0c" title="Sends a payload contained in a w_sock::ov via UDP. ">udp_tx()</a> and similar methods out onto the link.  <a href="#a3fba5669717435248ca7b7945a9b9d75">More...</a><br/></td></tr>
<tr class="separator:a3fba5669717435248ca7b7945a9b9d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0508cfebe874ba0f3f2f230b4120e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#ab0508cfebe874ba0f3f2f230b4120e0d">w_nic_rx</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, const int32_t msec)</td></tr>
<tr class="memdesc:ab0508cfebe874ba0f3f2f230b4120e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger netmap to make new received data available to <a class="el" href="backend__netmap_8c.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a>.  <a href="#ab0508cfebe874ba0f3f2f230b4120e0d">More...</a><br/></td></tr>
<tr class="separator:ab0508cfebe874ba0f3f2f230b4120e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a4664235583c583eee0a08a35a9c71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a10a4664235583c583eee0a08a35a9c71">w_rx_ready</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, struct w_sock_slist *sl)</td></tr>
<tr class="memdesc:a10a4664235583c583eee0a08a35a9c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a w_sock_slist with pointers to some sockets with pending inbound data.  <a href="#a10a4664235583c583eee0a08a35a9c71">More...</a><br/></td></tr>
<tr class="separator:a10a4664235583c583eee0a08a35a9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef58000f78363a1127c6f5e1da38bb6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a9ef58000f78363a1127c6f5e1da38bb6">w_iov_max_len</a> (const struct <a class="el" href="structw__iov.html">w_iov</a> *const v)</td></tr>
<tr class="memdesc:a9ef58000f78363a1127c6f5e1da38bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum size a given <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> may have for the given engine.  <a href="#a9ef58000f78363a1127c6f5e1da38bb6">More...</a><br/></td></tr>
<tr class="separator:a9ef58000f78363a1127c6f5e1da38bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960d81cdf30fb1dc693447ba4763f977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a960d81cdf30fb1dc693447ba4763f977">w_free</a> (struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const q)</td></tr>
<tr class="memdesc:a960d81cdf30fb1dc693447ba4763f977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue obtained via <a class="el" href="warpcore_8c.html#a7828b02675cf9e9c1465f3162033e22c" title="Allocate a w_iov tail queue for plen payload bytes, for eventual use with w_tx(). ...">w_alloc_len()</a>, <a class="el" href="warpcore_8c.html#a8eaba9c2482e4f78925648d3e12524d3" title="Allocate a w_iov tail queue of count packets, for eventual use with w_tx(). ">w_alloc_cnt()</a> or <a class="el" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a> back to warpcore.  <a href="#a960d81cdf30fb1dc693447ba4763f977">More...</a><br/></td></tr>
<tr class="separator:a960d81cdf30fb1dc693447ba4763f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bb31feffd5e9e2cda91aa4612bc103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a92bb31feffd5e9e2cda91aa4612bc103">w_free_iov</a> (struct <a class="el" href="structw__iov.html">w_iov</a> *const v)</td></tr>
<tr class="memdesc:a92bb31feffd5e9e2cda91aa4612bc103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> obtained via <a class="el" href="warpcore_8c.html#a7828b02675cf9e9c1465f3162033e22c" title="Allocate a w_iov tail queue for plen payload bytes, for eventual use with w_tx(). ...">w_alloc_len()</a>, <a class="el" href="warpcore_8c.html#a8eaba9c2482e4f78925648d3e12524d3" title="Allocate a w_iov tail queue of count packets, for eventual use with w_tx(). ">w_alloc_cnt()</a> or <a class="el" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a> back to warpcore.  <a href="#a92bb31feffd5e9e2cda91aa4612bc103">More...</a><br/></td></tr>
<tr class="separator:a92bb31feffd5e9e2cda91aa4612bc103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4f3655674a1befac066bd33657a8c0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__sock.html">w_sock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#aff4f3655674a1befac066bd33657a8c0">w_get_sock</a> (struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>, const uint32_t sip, const uint16_t sport, const uint32_t dip, const uint16_t dport)</td></tr>
<tr class="memdesc:aff4f3655674a1befac066bd33657a8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket bound to the given four-tuple &lt;source IP, source port, destination IP, destination port&gt;.  <a href="#aff4f3655674a1befac066bd33657a8c0">More...</a><br/></td></tr>
<tr class="separator:aff4f3655674a1befac066bd33657a8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d6f42d6066cbfca8842cf414a1c43a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a43d6f42d6066cbfca8842cf414a1c43a">w_init_rand</a> (void)</td></tr>
<tr class="memdesc:a43d6f42d6066cbfca8842cf414a1c43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init state for <a class="el" href="warpcore_8c.html#a61040d6a1057690cce90907f628a0e16" title="Return a random number. ">w_rand()</a> and <a class="el" href="warpcore_8c.html#a4ecb03f6a94c2911ab004803802a27c0" title="Calculate a uniformly distributed random number in [0, upper_bound) avoiding &quot;modulo bias&quot;...">w_rand_uniform()</a>.  <a href="#a43d6f42d6066cbfca8842cf414a1c43a">More...</a><br/></td></tr>
<tr class="separator:a43d6f42d6066cbfca8842cf414a1c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61040d6a1057690cce90907f628a0e16"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a61040d6a1057690cce90907f628a0e16">w_rand</a> (void)</td></tr>
<tr class="memdesc:a61040d6a1057690cce90907f628a0e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random number.  <a href="#a61040d6a1057690cce90907f628a0e16">More...</a><br/></td></tr>
<tr class="separator:a61040d6a1057690cce90907f628a0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecb03f6a94c2911ab004803802a27c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a4ecb03f6a94c2911ab004803802a27c0">w_rand_uniform</a> (const uint64_t upper_bound)</td></tr>
<tr class="memdesc:a4ecb03f6a94c2911ab004803802a27c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a uniformly distributed random number in [0, upper_bound) avoiding "modulo bias".  <a href="#a4ecb03f6a94c2911ab004803802a27c0">More...</a><br/></td></tr>
<tr class="separator:a4ecb03f6a94c2911ab004803802a27c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c90e71507fd384ce951e600da9f04f6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a0c90e71507fd384ce951e600da9f04f6">w_tx_pending</a> (const struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const q)</td></tr>
<tr class="memdesc:a0c90e71507fd384ce951e600da9f04f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs in <code>q</code> that are still waiting for transmission.  <a href="#a0c90e71507fd384ce951e600da9f04f6">More...</a><br/></td></tr>
<tr class="separator:a0c90e71507fd384ce951e600da9f04f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8908312be71047433d7e51059e240"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structw__engine.html">w_engine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a5ac8908312be71047433d7e51059e240">w_engine</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a5ac8908312be71047433d7e51059e240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return warpcore engine serving <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>.  <a href="#a5ac8908312be71047433d7e51059e240">More...</a><br/></td></tr>
<tr class="separator:a5ac8908312be71047433d7e51059e240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368cd1b58be4de19321744322f44c4a"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#af368cd1b58be4de19321744322f44c4a">w_ifname</a> (const struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>)</td></tr>
<tr class="memdesc:af368cd1b58be4de19321744322f44c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return name of interface associated with a warpcore engine.  <a href="#af368cd1b58be4de19321744322f44c4a">More...</a><br/></td></tr>
<tr class="separator:af368cd1b58be4de19321744322f44c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280e62a55aab21fe0b23a7e9ade1a588"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a280e62a55aab21fe0b23a7e9ade1a588">w_mtu</a> (const struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>)</td></tr>
<tr class="memdesc:a280e62a55aab21fe0b23a7e9ade1a588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return MTU of <a class="el" href="structw__engine.html" title="A warpcore backend engine. ">w_engine</a> <code>w</code>.  <a href="#a280e62a55aab21fe0b23a7e9ade1a588">More...</a><br/></td></tr>
<tr class="separator:a280e62a55aab21fe0b23a7e9ade1a588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d7e80a565b2ad694def961428e62ec"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#ab0d7e80a565b2ad694def961428e62ec">w_iov_sq_cnt</a> (const struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const q)</td></tr>
<tr class="memdesc:ab0d7e80a565b2ad694def961428e62ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>c</code>.  <a href="#ab0d7e80a565b2ad694def961428e62ec">More...</a><br/></td></tr>
<tr class="separator:ab0d7e80a565b2ad694def961428e62ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecaea95f6a94ce277eeed6f56ba400a"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#adecaea95f6a94ce277eeed6f56ba400a">w_mbps</a> (const struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>)</td></tr>
<tr class="memdesc:adecaea95f6a94ce277eeed6f56ba400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return link speed of <a class="el" href="structw__engine.html" title="A warpcore backend engine. ">w_engine</a> <code>w</code> in Mb/s.  <a href="#adecaea95f6a94ce277eeed6f56ba400a">More...</a><br/></td></tr>
<tr class="separator:adecaea95f6a94ce277eeed6f56ba400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214c76e7c54ad76e75cfa432a548cea9"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a214c76e7c54ad76e75cfa432a548cea9">w_drvname</a> (const struct <a class="el" href="structw__engine.html">w_engine</a> *const <a class="el" href="fuzz_8c.html#a8bedaecc1f0b28f6c3ec357ca967b33a">w</a>)</td></tr>
<tr class="memdesc:a214c76e7c54ad76e75cfa432a548cea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return name of the driver associated with the interface of a warpcore engine.  <a href="#a214c76e7c54ad76e75cfa432a548cea9">More...</a><br/></td></tr>
<tr class="separator:a214c76e7c54ad76e75cfa432a548cea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ebf15388748cfdcb739005f30266df"><td class="memItemLeft" align="right" valign="top">static const struct <a class="el" href="structw__sockopt.html">w_sockopt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a48ebf15388748cfdcb739005f30266df">w_get_sockopt</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a48ebf15388748cfdcb739005f30266df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current socket options.  <a href="#a48ebf15388748cfdcb739005f30266df">More...</a><br/></td></tr>
<tr class="separator:a48ebf15388748cfdcb739005f30266df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d68d8dde6e6c8f97f250c076c2e6b9a"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a0d68d8dde6e6c8f97f250c076c2e6b9a">w_get_sport</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a0d68d8dde6e6c8f97f250c076c2e6b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local port a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> is bound to.  <a href="#a0d68d8dde6e6c8f97f250c076c2e6b9a">More...</a><br/></td></tr>
<tr class="separator:a0d68d8dde6e6c8f97f250c076c2e6b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7644484ec2768497622b01587fc428ab"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a7644484ec2768497622b01587fc428ab">w_connected</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a7644484ec2768497622b01587fc428ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a socket is connected (i.e., <a class="el" href="warpcore_8h.html#aade6adf37002553de6cca667cacd5138" title="Connect a bound socket to a remote IP address and port. ">w_connect()</a> has been called on it) or not.  <a href="#a7644484ec2768497622b01587fc428ab">More...</a><br/></td></tr>
<tr class="separator:a7644484ec2768497622b01587fc428ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281a85c5e2760b47cd28cde4e6a5109b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8h.html#a281a85c5e2760b47cd28cde4e6a5109b">w_set_sockopt</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s, const struct <a class="el" href="structw__sockopt.html">w_sockopt</a> *const opt)</td></tr>
<tr class="memdesc:a281a85c5e2760b47cd28cde4e6a5109b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the socket options.  <a href="#a281a85c5e2760b47cd28cde4e6a5109b">More...</a><br/></td></tr>
<tr class="separator:a281a85c5e2760b47cd28cde4e6a5109b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="adb7cefb61123a68cf87f6e33270af1dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define w_iov_sq_initializer</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">q</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                          <a class="code" href="queue_8h.html#a0a6b92ae746b0340d6da9dc78b6b9056">\</a></div>
<div class="line"><a class="code" href="queue_8h.html#a0a6b92ae746b0340d6da9dc78b6b9056">        sq_head_initializer</a>(q), 0                                              \</div>
<div class="line">    }</div>
<div class="ttc" id="queue_8h_html_a0a6b92ae746b0340d6da9dc78b6b9056"><div class="ttname"><a href="queue_8h.html#a0a6b92ae746b0340d6da9dc78b6b9056">sq_head_initializer</a></div><div class="ttdeci">#define sq_head_initializer(head)</div><div class="ttdef"><b>Definition:</b> queue.h:380</div></div>
</div><!-- fragment -->
<p>Initializer for struct <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A struct <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a>, to be assigned to <code>q</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="client_8c-example.html#a22">client.c</a>, and <a class="el" href="server_8c-example.html#a17">server.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6c8c618c1c3811f7c7d8350c1c073567"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define w_sock_slist_initializer</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="queue_8h.html#a3473fc2c9a55a6b7b3a192ddc7589228">sl_head_initializer</a>(l)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for struct w_sock_slist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>A struct w_sock_slist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty w_sock_slist, to be assigned to <code>l</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aef8c8261fc14f3b65fdcc5a297f30cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_head </td>
          <td>(</td>
          <td class="paramtype">w_sock_slist&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structw__sock.html">w_sock</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A chain of <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket. </p>

</div>
</div>
<a class="anchor" id="a8eaba9c2482e4f78925648d3e12524d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_alloc_cnt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue of <code>count</code> packets, for eventual use with <a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51" title="Loops over the w_iov structures in the w_iov_sq o, sending them all over w_sock s. ">w_tx()</a>. </p>
<p>The tail queue must be later returned to warpcore <a class="el" href="warpcore_8c.html#a960d81cdf30fb1dc693447ba4763f977" title="Return a w_iov tail queue obtained via w_alloc_len(), w_alloc_cnt() or w_rx() back to warpcore...">w_free()</a>. If a <code>len</code> length is specified, limit the length of each buffer to the minimum of the MTU and this value. If a <code>off</code> offset is specified, leave this much extra space before <code>buf</code> in each <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. This is meant for upper-level protocols that wish to reserve space for their headers.</p>
<p>If there aren't enough buffers available to fulfill the request, <code>q</code> will be shorter than requested. It is up to the caller to check this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>Tail queue of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of packets in the returned tail queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of each <code>buf</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>Additional offset for <code>buf</code>. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a8eaba9c2482e4f78925648d3e12524d3_cgraph.png" border="0" usemap="#warpcore_8h_a8eaba9c2482e4f78925648d3e12524d3_cgraph" alt=""/></div>
<map name="warpcore_8h_a8eaba9c2482e4f78925648d3e12524d3_cgraph" id="warpcore_8h_a8eaba9c2482e4f78925648d3e12524d3_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a8e3e3376b3f23f1a1a8fc4be642f7710" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="144,5,235,32"/><area shape="rect" id="node3" href="backend_8h.html#a3ea12851bfb4f83f0843560797d0241e" title="w_alloc_iov_base" alt="" coords="283,5,408,32"/><area shape="rect" id="node4" href="backend_8h.html#a5bca37c30d432e0c16c44d8e0c087e5f" title="init_iov" alt="" coords="457,5,519,32"/><area shape="rect" id="node5" href="backend_8h.html#a7f3566b6a4f34920186abe13e80a2760" title="For a given buffer index, get a pointer to its beginning. " alt="" coords="568,5,651,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa17e20ed409edbfe18aa79ae5da640ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__iov.html">w_iov</a>* w_alloc_iov </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a spare <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> from the pool of the given warpcore engine. </p>
<p>Needs to be returned to w-&gt;iov via <a class="el" href="queue_8h.html#afe7589c38cef97495914215b1af25783">sq_insert_head()</a> or <a class="el" href="queue_8h.html#af5c9be0c2140ebb9aa9b247eedf0e5db">sq_concat()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of each <code>buf</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>Additional offset into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spare <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_aa17e20ed409edbfe18aa79ae5da640ff_cgraph.png" border="0" usemap="#warpcore_8h_aa17e20ed409edbfe18aa79ae5da640ff_cgraph" alt=""/></div>
<map name="warpcore_8h_aa17e20ed409edbfe18aa79ae5da640ff_cgraph" id="warpcore_8h_aa17e20ed409edbfe18aa79ae5da640ff_cgraph">
<area shape="rect" id="node2" href="backend_8h.html#a3ea12851bfb4f83f0843560797d0241e" title="w_alloc_iov_base" alt="" coords="144,5,269,32"/><area shape="rect" id="node3" href="backend_8h.html#a5bca37c30d432e0c16c44d8e0c087e5f" title="init_iov" alt="" coords="318,5,381,32"/><area shape="rect" id="node4" href="backend_8h.html#a7f3566b6a4f34920186abe13e80a2760" title="For a given buffer index, get a pointer to its beginning. " alt="" coords="429,5,512,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7828b02675cf9e9c1465f3162033e22c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_alloc_len </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>qlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue for <code>plen</code> payload bytes, for eventual use with <a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51" title="Loops over the w_iov structures in the w_iov_sq o, sending them all over w_sock s. ">w_tx()</a>. </p>
<p>The tail queue must be later returned to warpcore <a class="el" href="warpcore_8c.html#a960d81cdf30fb1dc693447ba4763f977" title="Return a w_iov tail queue obtained via w_alloc_len(), w_alloc_cnt() or w_rx() back to warpcore...">w_free()</a>. If a <code>len</code> length is specified, limit the length of each buffer to the minimum of the MTU and this value. If a <code>off</code> offset is specified, leave this much extra space before <code>buf</code> in each <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. This is meant for upper-level protocols that wish to reserve space for their headers.</p>
<p>If there aren't enough buffers available to fulfill the request, <code>q</code> will be shorter than requested. It is up to the caller to check this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>Tail queue of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qlen</td><td>Amount of payload bytes in the returned tail queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of each <code>buf</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>Additional offset for <code>buf</code>. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a7828b02675cf9e9c1465f3162033e22c_cgraph.png" border="0" usemap="#warpcore_8h_a7828b02675cf9e9c1465f3162033e22c_cgraph" alt=""/></div>
<map name="warpcore_8h_a7828b02675cf9e9c1465f3162033e22c_cgraph" id="warpcore_8h_a7828b02675cf9e9c1465f3162033e22c_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a8e3e3376b3f23f1a1a8fc4be642f7710" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="144,5,235,32"/><area shape="rect" id="node3" href="backend_8h.html#a3ea12851bfb4f83f0843560797d0241e" title="w_alloc_iov_base" alt="" coords="283,5,408,32"/><area shape="rect" id="node4" href="backend_8h.html#a5bca37c30d432e0c16c44d8e0c087e5f" title="init_iov" alt="" coords="457,5,519,32"/><area shape="rect" id="node5" href="backend_8h.html#a7f3566b6a4f34920186abe13e80a2760" title="For a given buffer index, get a pointer to its beginning. " alt="" coords="568,5,651,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8f5c782e319686927159612d3f455b7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__sock.html">w_sock</a>* w_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structw__sockopt.html">w_sockopt</a> *const&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to the given local UDP port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>The <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to bind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The local port number to bind to, in network byte order. If port is zero, a random local port will be chosen. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Socket options for this socket. Can be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a bound <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a8f5c782e319686927159612d3f455b7b_cgraph.png" border="0" usemap="#warpcore_8h_a8f5c782e319686927159612d3f455b7b_cgraph" alt=""/></div>
<map name="warpcore_8h_a8f5c782e319686927159612d3f455b7b_cgraph" id="warpcore_8h_a8f5c782e319686927159612d3f455b7b_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#aff4f3655674a1befac066bd33657a8c0" title="Get the socket bound to the given four&#45;tuple &lt;source IP, source port, destination IP..." alt="" coords="123,5,215,32"/><area shape="rect" id="node3" href="backend_8h.html#aa5e273595df14dd0f4ad2899eaebafe8" title="Netmap&#45;specific code to bind a warpcore socket. " alt="" coords="118,56,221,83"/><area shape="rect" id="node8" href="warpcore_8c.html#a71cc05810f16495f5f6e1889c96e5b6c" title="ins_sock" alt="" coords="132,107,207,133"/><area shape="rect" id="node4" href="backend__netmap_8c.html#a281a85c5e2760b47cd28cde4e6a5109b" title="Set the socket options. " alt="" coords="270,31,381,57"/><area shape="rect" id="node5" href="backend__netmap_8c.html#a3be98876f5c17d36d0436ca491ffd43a" title="pick_sport" alt="" coords="284,81,367,108"/><area shape="rect" id="node6" href="warpcore_8h.html#a4ecb03f6a94c2911ab004803802a27c0" title="Calculate a uniformly distributed random number in [0, upper_bound) avoiding &quot;modulo bias&quot;..." alt="" coords="429,81,544,108"/><area shape="rect" id="node7" href="klib_2krng_8h.html#a3864312439c8a4b1ca75c8f0cbb9ccff" title="kr_rand_r" alt="" coords="593,81,669,108"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a726b06c06493678f7f48c889bbcd30a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut a warpcore engine down cleanly. </p>
<p>In addition to calling into the backend-specific cleanup function, it frees up the extra buffers and other memory structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Backend engine. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a726b06c06493678f7f48c889bbcd30a5_cgraph.png" border="0" usemap="#warpcore_8h_a726b06c06493678f7f48c889bbcd30a5_cgraph" alt=""/></div>
<map name="warpcore_8h_a726b06c06493678f7f48c889bbcd30a5_cgraph" id="warpcore_8h_a726b06c06493678f7f48c889bbcd30a5_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a26c31751f7bb602b01bf00077ebd362d" title="Close a warpcore socket. " alt="" coords="139,31,210,57"/><area shape="rect" id="node3" href="backend_8h.html#a10352237f3cab978ad3dbe7f25acb8cc" title="The netmap backend performs no operation here. " alt="" coords="259,5,368,32"/><area shape="rect" id="node4" href="warpcore_8c.html#a811255f1e117572d31fd94afa11718a4" title="rem_sock" alt="" coords="274,56,353,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a26c31751f7bb602b01bf00077ebd362d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a warpcore socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to close. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a26c31751f7bb602b01bf00077ebd362d_cgraph.png" border="0" usemap="#warpcore_8h_a26c31751f7bb602b01bf00077ebd362d_cgraph" alt=""/></div>
<map name="warpcore_8h_a26c31751f7bb602b01bf00077ebd362d_cgraph" id="warpcore_8h_a26c31751f7bb602b01bf00077ebd362d_cgraph">
<area shape="rect" id="node2" href="backend_8h.html#a10352237f3cab978ad3dbe7f25acb8cc" title="The netmap backend performs no operation here. " alt="" coords="125,5,235,32"/><area shape="rect" id="node3" href="warpcore_8c.html#a811255f1e117572d31fd94afa11718a4" title="rem_sock" alt="" coords="141,56,219,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aade6adf37002553de6cca667cacd5138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int w_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a bound socket to a remote IP address and port. </p>
<p>Depending on the backend, this function may block until a MAC address has been resolved with ARP.</p>
<p>Calling <a class="el" href="warpcore_8c.html#aade6adf37002553de6cca667cacd5138" title="Connect a bound socket to a remote IP address and port. ">w_connect()</a> will make subsequent <a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51" title="Loops over the w_iov structures in the w_iov_sq o, sending them all over w_sock s. ">w_tx()</a> operations on the <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> enqueue payload data towards that destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip</td><td>Destination IPv4 address to bind to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port to bind to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, <code>errno</code> otherwise. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_aade6adf37002553de6cca667cacd5138_cgraph.png" border="0" usemap="#warpcore_8h_aade6adf37002553de6cca667cacd5138_cgraph" alt=""/></div>
<map name="warpcore_8h_aade6adf37002553de6cca667cacd5138_cgraph" id="warpcore_8h_aade6adf37002553de6cca667cacd5138_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a811255f1e117572d31fd94afa11718a4" title="rem_sock" alt="" coords="162,1132,241,1159"/><area shape="rect" id="node3" href="backend_8h.html#a0de137fe30801a3c8798185082b134be" title="Connect the given w_sock, using the netmap backend. " alt="" coords="139,1183,263,1209"/><area shape="rect" id="node50" href="warpcore_8c.html#a71cc05810f16495f5f6e1889c96e5b6c" title="ins_sock" alt="" coords="164,1233,239,1260"/><area shape="rect" id="node4" href="backend_8h.html#a03bc21b220cd1dbb450c6d3ea4f838c9" title="The IPv4 network prefix for the given IPv4 address and netmask. " alt="" coords="911,1132,977,1159"/><area shape="rect" id="node5" href="arp_8c.html#aad7ca3e847867c4dcc618d034aa42739" title="Return the Ethernet MAC address for target IP address dip. " alt="" coords="312,1005,411,1032"/><area shape="rect" id="node35" href="warpcore_8h.html#aff4f3655674a1befac066bd33657a8c0" title="Get the socket bound to the given four&#45;tuple &lt;source IP, source port, destination IP..." alt="" coords="1078,1169,1170,1196"/><area shape="rect" id="node49" href="backend__netmap_8c.html#a3be98876f5c17d36d0436ca491ffd43a" title="pick_sport" alt="" coords="320,1259,403,1285"/><area shape="rect" id="node6" href="arp_8c.html#ab57d1a0513207babcdb2f6a8a8295fae" title="Find the ARP cache entry associated with IPv4 address ip. " alt="" coords="459,1056,570,1083"/><area shape="rect" id="node7" href="backend_8h.html#a3ea12851bfb4f83f0843560797d0241e" title="w_alloc_iov_base" alt="" coords="1061,17,1187,44"/><area shape="rect" id="node10" href="eth_8h.html#a01df29c04e9962e458497dc6d3ea7da3" title="Return a pointer to the first data byte inside the Ethernet frame in buf. " alt="" coords="908,1056,980,1083"/><area shape="rect" id="node11" href="eth_8c.html#a81ff5f8f32f3f31da0fa707ebbb69b1b" title="Places an Ethernet frame into a TX ring. " alt="" coords="485,1107,544,1133"/><area shape="rect" id="node13" href="warpcore_8h.html#a3fba5669717435248ca7b7945a9b9d75" title="Push data placed in the TX rings via udp_tx() and similar methods out onto the link. " alt="" coords="1087,727,1161,753"/><area shape="rect" id="node14" href="warpcore_8h.html#ab0508cfebe874ba0f3f2f230b4120e0d" title="Trigger netmap to make new received data available to w_rx(). " alt="" coords="477,651,552,677"/><area shape="rect" id="node8" href="backend_8h.html#a5bca37c30d432e0c16c44d8e0c087e5f" title="init_iov" alt="" coords="1286,17,1349,44"/><area shape="rect" id="node9" href="backend_8h.html#a7f3566b6a4f34920186abe13e80a2760" title="For a given buffer index, get a pointer to its beginning. " alt="" coords="1443,17,1525,44"/><area shape="rect" id="node12" href="eth_8c.html#a84b1cdcdafabcab37d01ffff5a0e1938" title="ether_ntoa_r" alt="" coords="734,1107,829,1133"/><area shape="rect" id="node15" href="conn_8c.html#a69924c834acb11f94887f781e4241397" title="rx" alt="" coords="631,524,670,551"/><area shape="rect" id="node45" href="eth_8c.html#a659282bc0d2ea46d2d4817aa9a2f46e7" title="Receive an Ethernet frame. " alt="" coords="621,955,680,981"/><area shape="rect" id="node48" href="backend_8h.html#a2242871306406e5b7f993f173bb9ff4a" title="is_pipe" alt="" coords="619,651,682,677"/><area shape="rect" id="node16" href="warpcore_8h.html#a5ac8908312be71047433d7e51059e240" title="Return warpcore engine serving w_sock s. " alt="" coords="905,93,983,120"/><area shape="rect" id="node17" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i..." alt="" coords="756,499,807,525"/><area shape="rect" id="node19" href="conn_8c.html#a743c431b40b906bbe9baad4456a0e7c5" title="rx_pkts" alt="" coords="749,549,814,576"/><area shape="rect" id="node39" href="conn_8c.html#a1a9a96efc3be558373804c33a60df6b9" title="tx" alt="" coords="762,853,801,880"/><area shape="rect" id="node40" href="conn_8c.html#a3b5d57a3e32f9d5cc8a8fccfb2e0f5a9" title="tx_ack" alt="" coords="913,955,975,981"/><area shape="rect" id="node41" href="conn_8h.html#a526357c19864e7579573160573a55c33" title="pn_for_epoch" alt="" coords="731,347,831,373"/><area shape="rect" id="node42" href="pn_8c.html#a7f1a6720a0e3506c0553d13ad865510f" title="needs_ack" alt="" coords="739,397,824,424"/><area shape="rect" id="node43" href="conn_8c.html#a4a5deef512e20b125b45899c6c80c6fc" title="free_conn" alt="" coords="742,448,821,475"/><area shape="rect" id="node44" href="quant_8h.html#a84a768c49cd352e1c8a109bda56ef3a6" title="q_rx_ready" alt="" coords="738,296,825,323"/><area shape="rect" id="node18" href="warpcore_8h.html#aa17e20ed409edbfe18aa79ae5da640ff" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="899,43,989,69"/><area shape="rect" id="node20" href="quic_8c.html#a4e51fb8c9ebc5178b5131826ca26fb90" title="write_to_corpus" alt="" coords="887,296,1001,323"/><area shape="rect" id="node21" href="warpcore_8h.html#a7644484ec2768497622b01587fc428ab" title="Return whether a socket is connected (i.e., w_connect() has been called on it) or not..." alt="" coords="895,347,993,373"/><area shape="rect" id="node22" href="conn_8c.html#a042a55d10b57e402bf5982add4983181" title="get_conn_by_ipnp" alt="" coords="881,397,1007,424"/><area shape="rect" id="node23" href="warpcore_8h.html#a0d68d8dde6e6c8f97f250c076c2e6b9a" title="Return the local port a w_sock is bound to. " alt="" coords="1077,840,1171,867"/><area shape="rect" id="node24" href="pkt_8c.html#ab205cb10435c8caf476391325b68eb66" title="dec_pkt_hdr_beginning" alt="" coords="1240,448,1395,475"/><area shape="rect" id="node25" href="pkt_8h.html#a4bfe94fcdabe97c2898be1e6d6f5bc1d" title="is_lh" alt="" coords="1459,473,1509,500"/><area shape="rect" id="node26" href="pkt_8h.html#a05682f9ba0bc730b6f41b9597b756730" title="pkt_type_str" alt="" coords="1270,499,1365,525"/><area shape="rect" id="node27" href="pkt_8c.html#acda77940d975cd06aecc7f0aae9f2aa0" title="tx_vneg_resp" alt="" coords="894,651,994,677"/><area shape="rect" id="node28" href="conn_8h.html#a3b1788e29ec153bfcb2b7edc34c488a6" title="is_force_vneg_vers" alt="" coords="1057,651,1191,677"/><area shape="rect" id="node29" href="pkt_8c.html#aad4456e4786b31e02e1e4c81e265d442" title="log_pkt" alt="" coords="1092,549,1156,576"/><area shape="rect" id="node30" href="conn_8c.html#a370e079f6b872eb4fb70053eb3fd14a3" title="get_conn_by_cid" alt="" coords="884,195,1004,221"/><area shape="rect" id="node31" href="conn_8c.html#a1ae0706a577e85efbcfacf517a329dbe" title="vers_supported" alt="" coords="889,600,999,627"/><area shape="rect" id="node32" href="conn_8c.html#a51850847894ca6bd5bd7a3f06fc9f1ff" title="new_conn" alt="" coords="903,904,985,931"/><area shape="rect" id="node36" href="tls_8c.html#a00ca93e0c4b1bdde1a2e97a4ef13373e" title="init_tls" alt="" coords="914,245,974,272"/><area shape="rect" id="node37" href="conn_8h.html#ad2372a4b6e27ada905f0604c1725abf1" title="cid_cmp" alt="" coords="909,853,979,880"/><area shape="rect" id="node33" href="warpcore_8h.html#a4ecb03f6a94c2911ab004803802a27c0" title="Calculate a uniformly distributed random number in [0, upper_bound) avoiding &quot;modulo bias&quot;..." alt="" coords="1067,1239,1181,1265"/><area shape="rect" id="node34" href="klib_2krng_8h.html#a3864312439c8a4b1ca75c8f0cbb9ccff" title="kr_rand_r" alt="" coords="1279,1239,1355,1265"/><area shape="rect" id="node38" href="boot_8c.html#a3c48b0d616482494ace467ca05e01642" title="memcmp" alt="" coords="1086,967,1162,993"/><area shape="rect" id="node46" href="ip_8c.html#a83c3b73e5ae32815530bdb103a0a59ee" title="Receive processing for an IPv4 packet. " alt="" coords="756,955,807,981"/><area shape="rect" id="node47" href="arp_8c.html#adfea277e13c34a07fc16cb4455988d71" title="Receive an ARP packet, and react to it. " alt="" coords="752,1056,811,1083"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7644484ec2768497622b01587fc428ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool w_connected </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a socket is connected (i.e., <a class="el" href="warpcore_8h.html#aade6adf37002553de6cca667cacd5138" title="Connect a bound socket to a remote IP address and port. ">w_connect()</a> has been called on it) or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when connected, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a214c76e7c54ad76e75cfa432a548cea9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* w_drvname </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return name of the driver associated with the interface of a warpcore engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Driver name <code>w</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ac8908312be71047433d7e51059e240"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structw__engine.html">w_engine</a>* <a class="el" href="structw__engine.html">w_engine</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return warpcore engine serving <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The warpcore engine for <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf46056f39cb452d908ddac8cf6e57c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int w_fd </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the file descriptor associated with a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>. </p>
<p>For the netmap backend, this is the per-interface netmap file descriptor. It can be used for poll() or with event-loop libraries in the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket for which to get the underlying descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor.</dd></dl>
<p>For the socket backend, this an OS file descriptor of the underlying socket. It can be used for poll() or with event-loop libraries in the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket for which to get the underlying descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="a960d81cdf30fb1dc693447ba4763f977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue obtained via <a class="el" href="warpcore_8c.html#a7828b02675cf9e9c1465f3162033e22c" title="Allocate a w_iov tail queue for plen payload bytes, for eventual use with w_tx(). ...">w_alloc_len()</a>, <a class="el" href="warpcore_8c.html#a8eaba9c2482e4f78925648d3e12524d3" title="Allocate a w_iov tail queue of count packets, for eventual use with w_tx(). ">w_alloc_cnt()</a> or <a class="el" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a> back to warpcore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Tail queue of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92bb31feffd5e9e2cda91aa4612bc103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_free_iov </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__iov.html">w_iov</a> *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a single <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> obtained via <a class="el" href="warpcore_8c.html#a7828b02675cf9e9c1465f3162033e22c" title="Allocate a w_iov tail queue for plen payload bytes, for eventual use with w_tx(). ...">w_alloc_len()</a>, <a class="el" href="warpcore_8c.html#a8eaba9c2482e4f78925648d3e12524d3" title="Allocate a w_iov tail queue of count packets, for eventual use with w_tx(). ">w_alloc_cnt()</a> or <a class="el" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a> back to warpcore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> struct to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff4f3655674a1befac066bd33657a8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__sock.html">w_sock</a>* w_get_sock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>sport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>dip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>dport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the socket bound to the given four-tuple &lt;source IP, source port, destination IP, destination port&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sip</td><td>The source IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sport</td><td>The source port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dip</td><td>The destination IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dport</td><td>The destination port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> bound to the given four-tuple. </dd></dl>

</div>
</div>
<a class="anchor" id="a48ebf15388748cfdcb739005f30266df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const struct <a class="el" href="structw__sockopt.html">w_sockopt</a>* w_get_sockopt </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current socket options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The socket options for <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d68d8dde6e6c8f97f250c076c2e6b9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t w_get_sport </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the local port a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> is bound to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Pointer to <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Local port number in network byte-order, or zero if unbound. </dd></dl>

</div>
</div>
<a class="anchor" id="af368cd1b58be4de19321744322f44c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* w_ifname </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return name of interface associated with a warpcore engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Backend engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interface name. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d8850127dfaca15991ddd916380ce4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__engine.html">w_engine</a>* w_init </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ifname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>nbufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a warpcore engine on the given interface. </p>
<p>Ethernet and IPv4 source addresses and related information, such as the netmask, are taken from the active OS configuration of the interface. A default router, however, needs to be specified with <code>rip</code>, if communication over a WAN is desired. <code>nbufs</code> controls how many packet buffers the engine will attempt to allocate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifname</td><td>The OS name of the interface (e.g., "eth0"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rip</td><td>The default router to be used for non-local destinations. Can be zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbufs</td><td>Number of extra packet buffers to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized warpcore engine. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a3d8850127dfaca15991ddd916380ce4d_cgraph.png" border="0" usemap="#warpcore_8h_a3d8850127dfaca15991ddd916380ce4d_cgraph" alt=""/></div>
<map name="warpcore_8h_a3d8850127dfaca15991ddd916380ce4d_cgraph" id="warpcore_8h_a3d8850127dfaca15991ddd916380ce4d_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a43d6f42d6066cbfca8842cf414a1c43a" title="Init state for w_rand() and w_rand_uniform(). " alt="" coords="137,31,225,57"/><area shape="rect" id="node6" href="plat_8h.html#ac645a18d329f9204ceddb21bff751abd" title="Return the Ethernet MAC address of network interface i. " alt="" coords="131,81,231,108"/><area shape="rect" id="node7" href="plat_8h.html#aed8665163695e9a71d2d423f978c4b6a" title="Return the MTU of network interface i. " alt="" coords="133,132,230,159"/><area shape="rect" id="node8" href="plat_8h.html#a2f7eb56d857e3fc97476186dbf10d36b" title="Return the link status of network interface i. " alt="" coords="134,183,229,209"/><area shape="rect" id="node9" href="plat_8h.html#ac97867bf57fe48eb27fa344a9efc6168" title="Return the link speed in Mb/s of network interface i. " alt="" coords="128,233,235,260"/><area shape="rect" id="node10" href="plat_8h.html#aed348bdab1fec90be8e2a1ef3ef5b2cc" title="Return the short name of the driver associated with interface i. " alt="" coords="110,284,253,311"/><area shape="rect" id="node11" href="backend_8h.html#a1efe6c54e4e30260d1c2630726b98eb5" title="Initialize the warpcore netmap backend for engine w. " alt="" coords="134,335,229,361"/><area shape="rect" id="node3" href="warpcore_2lib_2include_2warpcore_2util_8h.html#aac10e28037a498b4d09ed99c55e9020d" title="Compute an FNV&#45;1a 64&#45;bit hash over the given buffer. " alt="" coords="328,5,403,32"/><area shape="rect" id="node4" href="klib_2krng_8h.html#aacc147637623ae1e16f7b8624975f2f9" title="kr_srand_r" alt="" coords="324,56,407,83"/><area shape="rect" id="node5" href="klib_2krng_8h.html#afb1117d9208c7537b22d596371cc40f1" title="kr_splitmix64" alt="" coords="484,56,583,83"/><area shape="rect" id="node12" href="arp_8c.html#a5857d8f27a0bcfa2b9dfe8308ac7befb" title="Update the MAC address associated with IPv4 address ip in the ARP cache. " alt="" coords="301,284,429,311"/><area shape="rect" id="node14" href="warpcore_8h.html#af368cd1b58be4de19321744322f44c4a" title="Return name of interface associated with a warpcore engine. " alt="" coords="326,335,405,361"/><area shape="rect" id="node15" href="backend_8h.html#a5bca37c30d432e0c16c44d8e0c087e5f" title="init_iov" alt="" coords="334,385,397,412"/><area shape="rect" id="node13" href="arp_8c.html#ab57d1a0513207babcdb2f6a8a8295fae" title="Find the ARP cache entry associated with IPv4 address ip. " alt="" coords="478,284,589,311"/><area shape="rect" id="node16" href="backend_8h.html#a7f3566b6a4f34920186abe13e80a2760" title="For a given buffer index, get a pointer to its beginning. " alt="" coords="492,385,575,412"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a43d6f42d6066cbfca8842cf414a1c43a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_init_rand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init state for <a class="el" href="warpcore_8c.html#a61040d6a1057690cce90907f628a0e16" title="Return a random number. ">w_rand()</a> and <a class="el" href="warpcore_8c.html#a4ecb03f6a94c2911ab004803802a27c0" title="Calculate a uniformly distributed random number in [0, upper_bound) avoiding &quot;modulo bias&quot;...">w_rand_uniform()</a>. </p>
<p>This <b>MUST</b> be called once prior to calling any of these functions! </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a43d6f42d6066cbfca8842cf414a1c43a_cgraph.png" border="0" usemap="#warpcore_8h_a43d6f42d6066cbfca8842cf414a1c43a_cgraph" alt=""/></div>
<map name="warpcore_8h_a43d6f42d6066cbfca8842cf414a1c43a_cgraph" id="warpcore_8h_a43d6f42d6066cbfca8842cf414a1c43a_cgraph">
<area shape="rect" id="node2" href="warpcore_2lib_2include_2warpcore_2util_8h.html#aac10e28037a498b4d09ed99c55e9020d" title="Compute an FNV&#45;1a 64&#45;bit hash over the given buffer. " alt="" coords="145,5,220,32"/><area shape="rect" id="node3" href="klib_2krng_8h.html#aacc147637623ae1e16f7b8624975f2f9" title="kr_srand_r" alt="" coords="141,56,224,83"/><area shape="rect" id="node4" href="klib_2krng_8h.html#afb1117d9208c7537b22d596371cc40f1" title="kr_splitmix64" alt="" coords="272,56,371,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af715f1dc66886b692a243b014997f171"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structw__iov.html">w_iov</a>* <a class="el" href="structw__iov.html">w_iov</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> with index <code>i</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Warpcore engine. </td></tr>
    <tr><td class="paramname">i</td><td>Index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af82d2bc9bb47d5a72795267fe6ef3af3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t w_iov_idx </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov.html">w_iov</a> *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> <code>v</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index between 0-nfbus. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ef58000f78363a1127c6f5e1da38bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t w_iov_max_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov.html">w_iov</a> *const&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum size a given <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> may have for the given engine. </p>
<p>Basically, subtracts the header space and any offset specified when allocating the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> from the MTU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> in question.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum length of the data in a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> for this engine. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0d7e80a565b2ad694def961428e62ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t w_iov_sq_cnt </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>c</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue to compute the payload length of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs in <code>q</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="client_8c-example.html#a49">client.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acec933a0dba371ff10bd35397aed87e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t w_iov_sq_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total payload length of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>c</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue to compute the payload length of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the payload lengths of the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs in <code>q</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="server_8c-example.html#a19">server.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adecaea95f6a94ce277eeed6f56ba400a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t w_mbps </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return link speed of <a class="el" href="structw__engine.html" title="A warpcore backend engine. ">w_engine</a> <code>w</code> in Mb/s. </p>
<p>Must not be modified by caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Link speed of <code>w</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a280e62a55aab21fe0b23a7e9ade1a588"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t w_mtu </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return MTU of <a class="el" href="structw__engine.html" title="A warpcore backend engine. ">w_engine</a> <code>w</code>. </p>
<p>Must not be modified by caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTU value in use by engine <code>w</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0508cfebe874ba0f3f2f230b4120e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool w_nic_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>msec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger netmap to make new received data available to <a class="el" href="backend__netmap_8c.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a>. </p>
<p>Iterates over any new data in the RX rings, calling <a class="el" href="eth_8c.html#a659282bc0d2ea46d2d4817aa9a2f46e7" title="Receive an Ethernet frame. ">eth_rx()</a> for each.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msec</td><td>Timeout in milliseconds. Pass zero for immediate return, -1 for infinite wait.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any data is ready for reading.</dd></dl>
<p>Trigger netmap to make new received data available to <a class="el" href="backend__netmap_8c.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msec</td><td>Timeout in milliseconds. Pass zero for immediate return, -1 for infinite wait.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any data is ready for reading. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_ab0508cfebe874ba0f3f2f230b4120e0d_cgraph.png" border="0" usemap="#warpcore_8h_ab0508cfebe874ba0f3f2f230b4120e0d_cgraph" alt=""/></div>
<map name="warpcore_8h_ab0508cfebe874ba0f3f2f230b4120e0d_cgraph" id="warpcore_8h_ab0508cfebe874ba0f3f2f230b4120e0d_cgraph">
<area shape="rect" id="node2" href="conn_8c.html#a69924c834acb11f94887f781e4241397" title="rx" alt="" coords="141,385,179,412"/><area shape="rect" id="node46" href="eth_8c.html#a659282bc0d2ea46d2d4817aa9a2f46e7" title="Receive an Ethernet frame. " alt="" coords="131,1855,189,1881"/><area shape="rect" id="node50" href="backend_8h.html#a2242871306406e5b7f993f173bb9ff4a" title="is_pipe" alt="" coords="129,1905,191,1932"/><area shape="rect" id="node3" href="warpcore_8h.html#a5ac8908312be71047433d7e51059e240" title="Return warpcore engine serving w_sock s. " alt="" coords="429,309,507,336"/><area shape="rect" id="node4" href="warpcore_8h.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i..." alt="" coords="265,208,316,235"/><area shape="rect" id="node6" href="conn_8c.html#a743c431b40b906bbe9baad4456a0e7c5" title="rx_pkts" alt="" coords="258,1019,323,1045"/><area shape="rect" id="node38" href="conn_8c.html#a1a9a96efc3be558373804c33a60df6b9" title="tx" alt="" coords="271,107,310,133"/><area shape="rect" id="node39" href="conn_8c.html#a3b5d57a3e32f9d5cc8a8fccfb2e0f5a9" title="tx_ack" alt="" coords="437,5,499,32"/><area shape="rect" id="node42" href="conn_8h.html#a526357c19864e7579573160573a55c33" title="pn_for_epoch" alt="" coords="241,411,341,437"/><area shape="rect" id="node43" href="pn_8c.html#a7f1a6720a0e3506c0553d13ad865510f" title="needs_ack" alt="" coords="248,461,333,488"/><area shape="rect" id="node44" href="conn_8c.html#a4a5deef512e20b125b45899c6c80c6fc" title="free_conn" alt="" coords="251,360,330,387"/><area shape="rect" id="node45" href="quant_8h.html#a84a768c49cd352e1c8a109bda56ef3a6" title="q_rx_ready" alt="" coords="247,259,334,285"/><area shape="rect" id="node5" href="warpcore_8h.html#aa17e20ed409edbfe18aa79ae5da640ff" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="423,208,513,235"/><area shape="rect" id="node7" href="quic_8c.html#a4e51fb8c9ebc5178b5131826ca26fb90" title="write_to_corpus" alt="" coords="411,1069,525,1096"/><area shape="rect" id="node8" href="warpcore_8h.html#a7644484ec2768497622b01587fc428ab" title="Return whether a socket is connected (i.e., w_connect() has been called on it) or not..." alt="" coords="419,1120,517,1147"/><area shape="rect" id="node9" href="conn_8c.html#a042a55d10b57e402bf5982add4983181" title="get_conn_by_ipnp" alt="" coords="405,1171,531,1197"/><area shape="rect" id="node10" href="warpcore_8h.html#a0d68d8dde6e6c8f97f250c076c2e6b9a" title="Return the local port a w_sock is bound to. " alt="" coords="621,512,715,539"/><area shape="rect" id="node11" href="pkt_8c.html#ab205cb10435c8caf476391325b68eb66" title="dec_pkt_hdr_beginning" alt="" coords="789,1525,944,1552"/><area shape="rect" id="node12" href="pkt_8h.html#a4bfe94fcdabe97c2898be1e6d6f5bc1d" title="is_lh" alt="" coords="993,1525,1042,1552"/><area shape="rect" id="node13" href="pkt_8h.html#a05682f9ba0bc730b6f41b9597b756730" title="pkt_type_str" alt="" coords="819,1576,914,1603"/><area shape="rect" id="node14" href="pkt_8c.html#acda77940d975cd06aecc7f0aae9f2aa0" title="tx_vneg_resp" alt="" coords="418,1019,518,1045"/><area shape="rect" id="node15" href="conn_8h.html#a3b1788e29ec153bfcb2b7edc34c488a6" title="is_force_vneg_vers" alt="" coords="601,781,735,808"/><area shape="rect" id="node16" href="pkt_8c.html#aad4456e4786b31e02e1e4c81e265d442" title="log_pkt" alt="" coords="636,1272,700,1299"/><area shape="rect" id="node17" href="conn_8c.html#a370e079f6b872eb4fb70053eb3fd14a3" title="get_conn_by_cid" alt="" coords="408,816,528,843"/><area shape="rect" id="node18" href="conn_8c.html#a1ae0706a577e85efbcfacf517a329dbe" title="vers_supported" alt="" coords="413,715,523,741"/><area shape="rect" id="node19" href="conn_8c.html#a51850847894ca6bd5bd7a3f06fc9f1ff" title="new_conn" alt="" coords="427,461,509,488"/><area shape="rect" id="node20" href="openssl_8h.html#a2514cd53d441b44478641a1643af622d" title="ptls_openssl_random\l_bytes" alt="" coords="595,563,741,605"/><area shape="rect" id="node21" href="quic_8h.html#ab2b6d16118c27c0f7c91dfac30c5d446" title="cid_cpy" alt="" coords="833,629,900,656"/><area shape="rect" id="node22" href="conn_8c.html#ae5beee50c7414b14d1efb1e3e8ebe1ee" title="add_dcid" alt="" coords="631,629,705,656"/><area shape="rect" id="node23" href="conn_8h.html#aa0fec7fdf46459b57e64dbe4e79a8dc4" title="conn_type" alt="" coords="825,335,908,361"/><area shape="rect" id="node24" href="tls_8c.html#a00ca93e0c4b1bdde1a2e97a4ef13373e" title="init_tls" alt="" coords="438,867,498,893"/><area shape="rect" id="node25" href="conn_8h.html#ad2372a4b6e27ada905f0604c1725abf1" title="cid_cmp" alt="" coords="433,1728,503,1755"/><area shape="rect" id="node27" href="conn_8c.html#abf07a95614d3f540d12bd3dc1bb4391f" title="get_cid_by_id" alt="" coords="417,917,519,944"/><area shape="rect" id="node28" href="conn_8c.html#ad504407d4193d0551f761b2ca720b005" title="conns_by_ipnp_update" alt="" coords="391,968,545,995"/><area shape="rect" id="node29" href="pkt_8c.html#a4df410764fdb5a8d7468492748e0e3ea" title="dec_pkt_hdr_remainder" alt="" coords="389,1677,547,1704"/><area shape="rect" id="node30" href="conn_8c.html#ade748bfd0c0c5eb3a94c22bb27c37987" title="pkt_ok_for_epoch" alt="" coords="804,1753,929,1780"/><area shape="rect" id="node31" href="conn_8c.html#a90b995546c499b521dcb4bf6cc7e39f1" title="epoch_in" alt="" coords="631,1475,705,1501"/><area shape="rect" id="node32" href="conn_8c.html#a9ef5d7dd45e20cc2cf7504fac35c37e0" title="rx_pkt" alt="" coords="439,664,497,691"/><area shape="rect" id="node34" href="conn_8c.html#a5d6639a237bb88d66f93760fc93000a5" title="rx_crypto" alt="" coords="430,1525,506,1552"/><area shape="rect" id="node35" href="pkt_8h.html#a2e3325ad951d933d49dcd1cd1e0c04f1" title="epoch_for_pkt_type" alt="" coords="400,1323,536,1349"/><area shape="rect" id="node36" href="stream_8c.html#acf612f3ac0b49aa8c7d6630c00e6b0ce" title="free_stream" alt="" coords="423,360,513,387"/><area shape="rect" id="node37" href="warpcore_8h.html#a92bb31feffd5e9e2cda91aa4612bc103" title="Return a single w_iov obtained via w_alloc_len(), w_alloc_cnt() or w_rx() back to warpcore..." alt="" coords="425,1373,511,1400"/><area shape="rect" id="node26" href="boot_8c.html#a3c48b0d616482494ace467ca05e01642" title="memcmp" alt="" coords="630,1728,706,1755"/><area shape="rect" id="node33" href="conn_8c.html#afd38904c68cab87424e6aa8db723fd38" title="enter_closing" alt="" coords="619,208,717,235"/><area shape="rect" id="node40" href="conn_8c.html#a0b0c1eff62e65d38a175b6df4ea4ce80" title="do_conn_mgmt" alt="" coords="613,31,723,57"/><area shape="rect" id="node41" href="conn_8c.html#a3ee439cb4dc64e21a0637dcd7e9dcb87" title="tx_stream" alt="" coords="628,132,708,159"/><area shape="rect" id="node47" href="eth_8c.html#a84b1cdcdafabcab37d01ffff5a0e1938" title="ether_ntoa_r" alt="" coords="243,1931,338,1957"/><area shape="rect" id="node48" href="ip_8c.html#a83c3b73e5ae32815530bdb103a0a59ee" title="Receive processing for an IPv4 packet. " alt="" coords="265,1981,316,2008"/><area shape="rect" id="node49" href="arp_8c.html#adfea277e13c34a07fc16cb4455988d71" title="Receive an ARP packet, and react to it. " alt="" coords="261,1880,320,1907"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3fba5669717435248ca7b7945a9b9d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_nic_tx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push data placed in the TX rings via <a class="el" href="udp_8c.html#a5ff6c06e976086b17457bc7766bb8e0c" title="Sends a payload contained in a w_sock::ov via UDP. ">udp_tx()</a> and similar methods out onto the link. </p>
<p>Also move any transmitted data back into the original w_iovs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine.</td></tr>
  </table>
  </dd>
</dl>
<p>Push data placed in the TX rings via <a class="el" href="udp_8c.html#a5ff6c06e976086b17457bc7766bb8e0c" title="Sends a payload contained in a w_sock::ov via UDP. ">udp_tx()</a> and similar methods out onto the link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61040d6a1057690cce90907f628a0e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t w_rand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random number. </p>
<p>Fast, but not cryptographically secure. Implements xoroshiro128+; see <a href="https://en.wikipedia.org/wiki/Xoroshiro128%2B">https://en.wikipedia.org/wiki/Xoroshiro128%2B</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Random number. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a61040d6a1057690cce90907f628a0e16_cgraph.png" border="0" usemap="#warpcore_8h_a61040d6a1057690cce90907f628a0e16_cgraph" alt=""/></div>
<map name="warpcore_8h_a61040d6a1057690cce90907f628a0e16_cgraph" id="warpcore_8h_a61040d6a1057690cce90907f628a0e16_cgraph">
<area shape="rect" id="node2" href="klib_2krng_8h.html#a3864312439c8a4b1ca75c8f0cbb9ccff" title="kr_rand_r" alt="" coords="118,5,194,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4ecb03f6a94c2911ab004803802a27c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t w_rand_uniform </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a uniformly distributed random number in [0, upper_bound) avoiding "modulo bias". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_bound</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random number. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_a4ecb03f6a94c2911ab004803802a27c0_cgraph.png" border="0" usemap="#warpcore_8h_a4ecb03f6a94c2911ab004803802a27c0_cgraph" alt=""/></div>
<map name="warpcore_8h_a4ecb03f6a94c2911ab004803802a27c0_cgraph" id="warpcore_8h_a4ecb03f6a94c2911ab004803802a27c0_cgraph">
<area shape="rect" id="node2" href="klib_2krng_8h.html#a3864312439c8a4b1ca75c8f0cbb9ccff" title="kr_rand_r" alt="" coords="169,5,245,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af21a4e848c9199be729d01d20b8eea3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return any new data that has been received on a socket by appending it to the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>i</code>. </p>
<p>The tail queue must eventually be returned to warpcore via <a class="el" href="warpcore_8h.html#a960d81cdf30fb1dc693447ba4763f977" title="Return a w_iov tail queue obtained via w_alloc_len(), w_alloc_cnt() or w_rx() back to warpcore...">w_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> for which the application would like to receive new data. </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue to append new data to.</td></tr>
  </table>
  </dd>
</dl>
<p>Return any new data that has been received on a socket by appending it to the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue <code>i</code>.</p>
<p>Appends all data to the <a class="el" href="structw__sock.html#a3db894eae177fa4a879dffd4e9ad706e" title="Tail queue containing incoming unread data. ">w_sock::iv</a> socket buffers of the respective <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> for which the application would like to receive new data. </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> tail queue to append new data to. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_af21a4e848c9199be729d01d20b8eea3d_cgraph.png" border="0" usemap="#warpcore_8h_af21a4e848c9199be729d01d20b8eea3d_cgraph" alt=""/></div>
<map name="warpcore_8h_af21a4e848c9199be729d01d20b8eea3d_cgraph" id="warpcore_8h_af21a4e848c9199be729d01d20b8eea3d_cgraph">
<area shape="rect" id="node2" href="warpcore_8h.html#aa17e20ed409edbfe18aa79ae5da640ff" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="104,5,195,32"/><area shape="rect" id="node3" href="backend_8h.html#a3ea12851bfb4f83f0843560797d0241e" title="w_alloc_iov_base" alt="" coords="243,5,368,32"/><area shape="rect" id="node4" href="backend_8h.html#a5bca37c30d432e0c16c44d8e0c087e5f" title="init_iov" alt="" coords="417,5,479,32"/><area shape="rect" id="node5" href="backend_8h.html#a7f3566b6a4f34920186abe13e80a2760" title="For a given buffer index, get a pointer to its beginning. " alt="" coords="528,5,611,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a10a4664235583c583eee0a08a35a9c71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t w_rx_ready </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__engine.html">w_engine</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct w_sock_slist *const&#160;</td>
          <td class="paramname"><em>sl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a w_sock_slist with pointers to some sockets with pending inbound data. </p>
<p>Data can be obtained via <a class="el" href="backend__netmap_8c.html#af21a4e848c9199be729d01d20b8eea3d" title="Return any new data that has been received on a socket by appending it to the w_iov tail queue i...">w_rx()</a> on each <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> in the list. Call can optionally block to wait for at least one ready connection. Will return the number of ready connections, or zero if none are ready. When the return value is not zero, a repeated call may return additional ready sockets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Backend engine. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sl</td><td>Empty and initialized w_sock_slist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of connections that are ready for reading. </dd></dl>

</div>
</div>
<a class="anchor" id="a281a85c5e2760b47cd28cde4e6a5109b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_set_sockopt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structw__sockopt.html">w_sockopt</a> *const&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the socket options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>{ parameter_description } </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4f053bd8ffef52d164823134d732f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_tx </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loops over the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a> <code>o</code>, sending them all over <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </p>
<p>Places the payloads into IPv4 UDP packets, and attempts to move them into TX rings. Will force a NIC TX if all rings are full, retry the failed w_iovs. The (last batch of) packets are not send yet; <a class="el" href="backend__netmap_8c.html#a3fba5669717435248ca7b7945a9b9d75" title="Push data placed in the TX rings via udp_tx() and similar methods out onto the link. ">w_nic_tx()</a> needs to be called (again) for that. This is, so that an application has control over exactly when to schedule packet I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket to transmit over. </td></tr>
    <tr><td class="paramname">o</td><td><a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a> to send.</td></tr>
  </table>
  </dd>
</dl>
<p>Loops over the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a> <code>o</code>, sending them all over <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>.</p>
<p>This backend uses the Socket API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket to transmit over. </td></tr>
    <tr><td class="paramname">o</td><td><a class="el" href="structw__iov__sq.html" title="A tail queue of w_iov I/O vectors. ">w_iov_sq</a> to send. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8h_ac4f053bd8ffef52d164823134d732f51_cgraph.png" border="0" usemap="#warpcore_8h_ac4f053bd8ffef52d164823134d732f51_cgraph" alt=""/></div>
<map name="warpcore_8h_ac4f053bd8ffef52d164823134d732f51_cgraph" id="warpcore_8h_ac4f053bd8ffef52d164823134d732f51_cgraph">
<area shape="rect" id="node2" href="warpcore_8h.html#a7644484ec2768497622b01587fc428ab" title="Return whether a socket is connected (i.e., w_connect() has been called on it) or not..." alt="" coords="365,5,464,32"/><area shape="rect" id="node3" href="udp_8c.html#a5ff6c06e976086b17457bc7766bb8e0c" title="Sends a payload contained in a w_sock::ov via UDP. " alt="" coords="111,107,172,133"/><area shape="rect" id="node17" href="backend__netmap_8c.html#a3fba5669717435248ca7b7945a9b9d75" title="Push data placed in the TX rings via udp_tx() and similar methods out onto the link. " alt="" coords="104,157,179,184"/><area shape="rect" id="node4" href="eth_8h.html#a01df29c04e9962e458497dc6d3ea7da3" title="Return a pointer to the first data byte inside the Ethernet frame in buf. " alt="" coords="379,56,451,83"/><area shape="rect" id="node5" href="ip_8h.html#ae9f26c7f5dc4d2ba6bd03e86a42783da" title="Return a pointer to the payload data of the IPv4 packet in a buffer. " alt="" coords="236,208,300,235"/><area shape="rect" id="node6" href="ip_8c.html#a8d617b65b95abcb1abb3740537e46e34" title="IPv4 transmit processing for the w_iov v of length len. " alt="" coords="227,107,309,133"/><area shape="rect" id="node14" href="in__cksum_8c.html#a91b5a9539546f7879e7f3183e8db41af" title="udp_cksum" alt="" coords="370,208,459,235"/><area shape="rect" id="node15" href="eth_8c.html#a81ff5f8f32f3f31da0fa707ebbb69b1b" title="Places an Ethernet frame into a TX ring. " alt="" coords="239,259,297,285"/><area shape="rect" id="node7" href="warpcore_8h.html#a4ecb03f6a94c2911ab004803802a27c0" title="Calculate a uniformly distributed random number in [0, upper_bound) avoiding &quot;modulo bias&quot;..." alt="" coords="357,107,472,133"/><area shape="rect" id="node9" href="in__cksum_8c.html#a262ae86742cd94bef7aa644688a88816" title="ip_cksum" alt="" coords="375,157,454,184"/><area shape="rect" id="node8" href="klib_2krng_8h.html#a3864312439c8a4b1ca75c8f0cbb9ccff" title="kr_rand_r" alt="" coords="550,107,626,133"/><area shape="rect" id="node10" href="in__cksum_8c.html#afe46e60c9c3dcec077eb140e7c032c2c" title="csum_oc16_sse" alt="" coords="529,157,647,184"/><area shape="rect" id="node13" href="in__cksum_8c.html#a7ee8c766405745694128ec30e7c82f5a" title="csum_oc16_reduce" alt="" coords="521,208,655,235"/><area shape="rect" id="node11" href="in__cksum_8c.html#abdeb03525d2385ea8afe255717a04a8a" title="xmm_shift_left" alt="" coords="707,132,815,159"/><area shape="rect" id="node12" href="in__cksum_8c.html#abff563ca718f2c5d4012f12af289b5b1" title="xmm_shift_right" alt="" coords="704,183,819,209"/><area shape="rect" id="node16" href="eth_8c.html#a84b1cdcdafabcab37d01ffff5a0e1938" title="ether_ntoa_r" alt="" coords="367,259,462,285"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0c90e71507fd384ce951e600da9f04f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t w_tx_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov__sq.html">w_iov_sq</a> *const&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs in <code>q</code> that are still waiting for transmission. </p>
<p>Only valid after <a class="el" href="warpcore_8h.html#ac4f053bd8ffef52d164823134d732f51" title="Loops over the w_iov structures in the w_iov_sq o, sending them all over w_sock s. ">w_tx()</a> has been called on <code>p</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A tail queue of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs not yet transmitted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 20 2019 11:39:14 for quant by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
